geom_node_point(size = 5, color = "dodgerblue") + # Customize node appearance
geom_node_text(aes(label = name), repel = TRUE, size = 3) + # Add node labels
theme_void() + # Remove grid and axes for cleaner appearance
ggtitle("Zachary Karate Club Network") # Add a title
X11()
# Plot the network using ggraph
ggraph(karate_graph, layout = "fr") + # 'fr' stands for the Fruchterman-Reingold layout
geom_edge_link(aes(edge_alpha = 0.5), color = "grey") + # Customize edge appearance
geom_node_point(size = 5, color = "dodgerblue") + # Customize node appearance
geom_node_text(aes(label = name), repel = TRUE, size = 3) + # Add node labels
theme_void() + # Remove grid and axes for cleaner appearance
ggtitle("Zachary Karate Club Network") # Add a title
V(karate_graph)$name <- seq_len(vcount(karate_graph))
X11()
# Plot the network using ggraph
ggraph(karate_graph, layout = "fr") + # 'fr' stands for the Fruchterman-Reingold layout
geom_edge_link(aes(edge_alpha = 0.5), color = "grey") + # Customize edge appearance
geom_node_point(size = 5, color = "dodgerblue") + # Customize node appearance
geom_node_text(aes(label = name), repel = TRUE, size = 3) + # Add node labels
theme_void() + # Remove grid and axes for cleaner appearance
ggtitle("Zachary Karate Club Network") # Add a title
# Load the Zachary Karate Club dataset from igraph
karate_graph <- make_graph("Zachary")
karate_graph
# Load required library
library(igraph)
# Load the Zachary Karate Club dataset
karate_graph <- make_graph("Zachary")
# List of community detection methods in igraph
community_methods <- list(
"fast_greedy" = cluster_fast_greedy,
"edge_betweenness" = cluster_edge_betweenness,
"label_propagation" = cluster_label_prop,
"leading_eigenvector" = cluster_leading_eigen,
"louvain" = cluster_louvain,
"walktrap" = cluster_walktrap,
"infomap" = cluster_infomap,
"spinglass" = function(graph) cluster_spinglass(graph, spins = 10)
)
# Initialize a list to store results
modularity_scores <- list()
# Compute communities and modularity for each method
for (method_name in names(community_methods)) {
cat("Processing:", method_name, "\n")
# Compute community structure
community <- tryCatch(
community_methods[[method_name]](karate_graph),
error = function(e) NULL
)
# Calculate modularity if community detection succeeded
if (!is.null(community)) {
modularity_scores[[method_name]] <- modularity(community)
} else {
modularity_scores[[method_name]] <- NA
}
}
# Convert modularity scores to a sorted data frame
modularity_df <- data.frame(
Method = names(modularity_scores),
Modularity = unlist(modularity_scores)
)
modularity_df <- modularity_df[order(-modularity_df$Modularity, na.last = TRUE), ]
# Print the results
print(modularity_df)
?modularity_matrix
sqrt(90)
sqrt(10)
9.5+3.2
100*(3/12.7)
100*(9.5/12.7)
140/2.4
140/2,5
140/2.5
solve(c(1/2,1/4))
(c(1/2,1/4))^-1
(c(1/2,1/4))^(-1)
(c(1/2,1/4))^2
(c(2,1/4))^2
(c(2,4))^2
118,06/4
118.06/4
118.06/4   + 543,64/4
118.06/4   + 543.64/4
exp(2.40)
exp(5)
log(34)
sqrt(34)
plot(c(9,0,2,3,4,2), c(1,2,3,4,5,6))
plot(c(9,0,2,3,4,2), c(1,2,3,4,5,6))
plot(c(9,0,2,3,4,2), c(1,2,3,4,5,6), type="l")
plot( c(1,2,3,4,5,6),c(9,0,2,3,4,2), type="l")
plot( c(1,2,3,4,5,6),c(9,0,2,3,4,2), type="l", log="xy")
plot( c(1,2,3,4,5,6),c(9,4,2,3,4,2), type="l", log="xy")
1-(1-0.3)^7
x1=1-(1-0.3)^7
x1=1-(1-0.3*x1)^7
x1=1-(1-0.3*x1)^7
x1=1-(1-0.3*x1)^7
x1=1-(1-0.3*x1)^7
x1=1-(1-0.3*x1)^7
x1=1-(1-0.3*x1)^7
x1=1-(1-0.3*x1)^7
x1=1-(1-0.3*x1)^7
x1=1-(1-0.3*x1)^7
x1=1-(1-0.3*x1)^7
x1=1-(1-0.3*x1)^7
x1=1-(1-0.3*x1)^7
x1=1-(1-0.3*x1)^7
x1=1-(1-0.3*x1)^7
x1=1-(1-0.3*x1)^7
x1=1-(1-0.3*x1)^7
x1=1-(1-0.3*x1)^7
x1=1-(1-0.3*x1)^7
x1=1-(1-0.3*x1)^7
x1=1-(1-0.3*x1)^7
x1=1-(1-0.3*x1)^7
x1=1-(1-0.3*x1)^7
x1=1-(1-0.3*x1)^7
x1=1-(1-0.3*x1)^7
x1=1-(1-0.3*x1)^7
x1=1-(1-0.3*x1)^7
x1=1-(1-0.3*x1)^7
x1=1-(1-0.3*x1)^7
x1=1-(1-0.3*x1)^7
x1=1-(1-0.3*x1)^7
x1=1-(1-0.3*x1)^7
x1=1-(1-0.3*x1)^7
x1=1-(1-0.2*)^2
x1=1-(1-0.2*x1)^2
x1=1
x1=1-(1-0.2*x1)^2
x1=1-(1-0.2*x1)^2
x1=1-(1-0.2*x1)^2
x1=1-(1-0.2*x1)^2
x1=1-(1-0.2*x1)^2
x1=1-(1-0.2*x1)^2
x1=1-(1-0.2*x1)^2
x1=1-(1-0.2*x1)^2
x1=1-(1-0.2*x1)^2
x1=1-(1-0.2*x1)^2
x1=1-(1-0.2*x1)^2
x1=1-(1-0.2*x1)^2
x1=1-(1-0.2*x1)^2
x1=1-(1-0.2*x1)^2
x1=1-(1-0.2*x1)^2
x1=1-(1-0.2*x1)^2
x1=1-(1-0.2*x1)^2
x1=1-(1-0.2*x1)^2
x1=1-(1-0.2*x1)^2
x1=1-(1-0.2*x1)^2
library(igraph)
# Crea un grafo bipartito: nodi di tipo U e V
# Ad esempio, nodi U: 1, 2, 3 e nodi V: A, B, C
edges <- c(1, "A", 1, "B", 2, "A", 2, "C", 3, "B", 3, "C")
g <- graph_from_edgelist(matrix(edges, nc = 2, byrow = TRUE), directed = FALSE)
# Aggiungi l'attributo bipartito
V(g)$type <- bipartite_mapping(g)$type
# Proietta il grafo sul primo insieme (U)
proj <- bipartite_projection(g)
View(proj)
# Mostra il grafo risultante
print(proj_u)
proj_u <- proj[[1]]  # Proiezione sui nodi di tipo U
# Mostra il grafo risultante
print(proj_u)
plot(proj_u, vertex.label = V(proj_u)$name)
plot(proj_u, vertex.label = V(proj_u)$name)
gc()
gc()
gc()
seq(2,100, by=2)
x<-seq(2,100, by=2)
x= x/50
sum(x)
x<-seq(2,100, by=2)
x<- x(sum(x))
x<- x/(sum(x))
sum(x)
cbind(seq(1,50),x)
cbind(seq(1,50),x, cumsum(x))
log(0.5)
log(1)
log( (3-2.5)/(3-2.5*2))
log( (9-2.5)/(9-2.5*2))
log( (8-2.5)/(8-2.5*2))
log( (7-2.5)/(7-2.5*2))
log( (6-2.5)/(6-2.5*2))
log( (16-2.5)/(16-2.5*2))
log(-0.6/-0.5)
log(-0.6/-0.2)
0.6/0.2
log(0.1)
log(-0.6/-0.54)
(-0.6/-0.54)
log(-0.6/-0.1)
round(runif(1,1,100),1)
round(runif(1,1,100))
round(runif(1,1,100))
round(runif(1,1,100))
round(runif(1,1,100))
round(runif(1,1,100))
round(runif(100,1,100))
round(runif(1,1,100))
round(runif(1,1,100))
round(runif(1,1,100))
round(runif(1,1,100))
round(runif(1,1,100))
round(runif(1,1,100))
round(runif(1,1,100))
round(runif(1,1,100))
round(runif(1,1,100))
round(runif(1,1,100))
round(runif(1,1,100))
round(runif(1,1,100))
round(runif(1,1,100))
round(runif(1,1,100))
12000*0.22
30000*0.15
7040+4500+1000
0.22*18000
c(1,5,12,27)/5
print("Davide è uno studente modell000")
i = 7
while(i>4)>{
?while
()
i = 7
while(i>4){
print("Davide è uno studente modell000")
}
i = 7
while(i>4){
print("Davide ama il Comini")
}
dati = read.csv(file.choose())
table(dati$fact_check_ground_truth_value)
round(runif(50, 1,10))*10
round(runif(1,1,133))
round(runif(1,1,133))
round(runif(1,1,133))
round(runif(1,1,133))
round(runif(1,1,133))
round(runif(1,1,133))
round(runif(1,1,133))
round(runif(1,1,133))
round(runif(1,1,133))
(sqrt(3)*14^2)/4
(sqrt(3)*44^2)/4
sqrt(3)*14
(sqrt(3)*14)/2
(sqrt(3)*44)/2
38,11-6,06
38.11-6.06
sqrt(25^2-13^2)
((838.31+84.87+(sqrt(838.31*84.87)))*21.35)/3
(sqrt(3)*44^2)/3
(sqrt(3)*44^2)/4
(sqrt(3)*14^2)/4
sqrt(44^2 - 22^2)
sqrt(25^2 - 13^2)
((838.31+84.87+sqrt(838.31*84.87))*21.35)/3
3*(7147)/((838.31+84.87+sqrt(838.31*84.87))*21.35))
3*(7147)/((838.31+84.87+sqrt(838.31*84.87))*21.35)
3*(7147)/((838.31+84.87+sqrt(838.31*84.87)))
sqrt(25^2-13^2)
(sqrt(3)*14)/2
(sqrt(3)*44)/2
sqrt(25^2-12^2)
sqrt(25^2-14^2)
sqrt(25^2-15^2)
sqrt(25^2-16^2)
sqrt(25^2-17^2)
sqrt(19.05^2+22^2)
sqrt(6.06^2+7^2)
sqrt((25)^2-(29.10-9.26)^2)
((838.31+84.87+sqrt(838.31*84.87))*15.21)/3
((838.31+84.87+sqrt(838.31*84.87))*16.21)/3
((838.31+84.87+sqrt(838.31*84.87))*17.21)/3
((838.31+84.87+sqrt(838.31*84.87))*19.21)/3
((838.31+84.87+sqrt(838.31*84.87))*18.21)/3
((838.31+84.87+sqrt(838.31*84.87))*17.21)/3
((838.31+84.87+sqrt(838.31*84.87))*17.89)/3
sqrt((25)^2-(20)^2)
sqrt((25)^2-(19)^2)
sqrt((25)^2-(16)^2)
sqrt((25)^2-(17)^2)
sqrt((7)^2+(6.06)^2)
sqrt((22)^2+(19)^2)
sqrt((7)^2+(6)^2)
sqrt((21.35)^2-(13)^2)
((838.31+84.87+sqrt(838.31*84.87))*16.93)/3
sqrt((25)^2-(15)^2)
sqrt((20)^2-(13)^2)
((838.31+84.87+sqrt(838.31*84.87))*15.93)/3
(44+14)*20
1160/2
sqrt((20)^2-(13)^2)
580*3
sqrt((20)^2-(13)^2)
((838.31+84.87+sqrt(838.31*84.87))*15.93)
sqrt((44)^2-(22)^2)
sqrt((14)^2-(7)^2)
sqrt((20)^2-(13)^2)
sqrt((20)^2-(15)^2)
sqrt((20)^2-(10)^2)
((838.31+84.87+sqrt(838.31*84.87))*17.32)
((838.31+84.87+sqrt(838.31*84.87))*17.32)/3
sqrt((25)^2-(13)^2)
((838.31+84.87+sqrt(838.31*84.87))*21.35)/3
sqrt((25)^2-(20)^2)
sqrt((20)^2-(q5)^2)
sqrt((20)^2-(15)^2)
sqrt((20)^2-(13)^2)
((838.31+84.87+sqrt(838.31*84.87))*15.93)/3
12.12*14/2
38.11*44/2
((838.42+84.87+sqrt(838.42*84.87))*15.93)/3
sqrt(((20)^2)-(13)^2)
sqrt(((20)^2)-((13)^2))
5*sqrt(13)
44*sqrt(3)
sqrt(325)
44*sqrt(3)
14/(sqrt(3)*2)
(sqrt(3)*44)/6
(sqrt(3)*14)/6
sqrrt(20^2-(8.66)^2)
sqrt(20^2-(8.66)^2)
seq(1,16)
sum(seq(1,16))
sum(seq(1,15))
sum(seq(1,64))
sum(seq(0,63))
1024*9
round(runif(1, 1,20)))
round(runif(1, 1,20))
sqrt(80^2-48^2)
sqrt((80^2)-(48^2))
80*64
64^2
5120-4096
1024/128
6^2
64^2
4096*8
round(runif(1,11,43))
round(runif(1,11,43))
round(runif(1,11,43))
round(runif(1,1,70))
sum(4+45+12+80+54+4+60+12+24+104+72+6+32+40+36+96+72+7+20+12+48+72)
sum(20+6+7+12+18+21+8+8+25+14+12+28+10+26+37+12+62+4+4+4+28+12+6+22)
90*100
9000/30
?rbinom
rbinom(n*k, 1, prob)
rbinom(n*k, 1, prob)
n = 3;
k = 3;
prob = 0.5;
matrice = matrix(NA, nrow=3, ncol=k)
rbinom(n*k, 1, prob)
matrice = matrix(rbinom(n*k, 1, theta), nrow=3, ncol=k)
theta = 0.5;
matrice = matrix(rbinom(n*k, 1, theta), nrow=3, ncol=k)
matrice
n = 3;
k = 5;
theta = 0.5;
matrice = matrix(rbinom(n*k, 1, theta), nrow=3, ncol=k)
matrice
setwd("C:/Users/Bruno/Desktop/Uni-parallele/Parallel-Implementation-Systems-of-Boolean-linear-equations-using-XOR-operations/test")
setwd("C:/Users/Bruno/Desktop/Uni-parallele/Parallel-Implementation-Systems-of-Boolean-linear-equations-using-XOR-operations/test")
n = 3;
k = 5;
theta = 0.5;
matrice = matrix(rbinom(n*k, 1, theta), nrow=3, ncol=k)
matrice
save
# Salva la matrice in un file di testo
write.table(matrice, file = "test2.txt", row.names = FALSE, col.names = FALSE, sep = " ")
n = 3;
k = 5;
theta = 0.1;
matrice = matrix(rbinom(n*k, 1, theta), nrow=3, ncol=k)
matrice
colSums(matrice)
for (x in 1:k) {
if (sum(matrice[,k]) ==0){
matrice[round(runif(1,1,5)),k]=1
}
}
matrice
for (x in 1:k) {
if (sum(matrice[,k]) == 0){
matrice[round(runif(1,1,n)),k]=1
}
}
matrice
round(runif(1,1,n))
round(runif(1,1,n))
round(runif(1,1,n))
round(runif(1,1,n))
round(runif(1,1,n))
round(runif(1,1,n))
round(runif(1,1,n))
round(runif(1,1,n))
round(runif(1,1,n))
round(runif(1,1,n))
round(runif(1,1,n))
round(runif(1,1,n))
round(runif(1,1,n))
round(runif(1,1,n))
round(runif(1,1,n))
round(runif(1,1,n))
round(runif(1,1,n))
round(runif(1,1,n))
round(runif(1,1,n))
round(runif(1,1,n))
round(runif(1,1,n))
round(runif(1,1,n))
for (x in 1:k) {
if (sum(matrice[,x]) == 0){
matrice[round(runif(1,1,n)),x]=1
}
}
matrice
# Salva la matrice in un file di testo
write.table(matrice, file = "test2.txt", row.names = FALSE, col.names = FALSE, sep = " ")
setwd("C:/Users/Bruno/Desktop/Uni-parallele/Parallel-Implementation-Systems-of-Boolean-linear-equations-using-XOR-operations/test")
n = 5;
k = 9;
theta = 0.1;
matrice = matrix(rbinom(n*k, 1, theta), nrow=3, ncol=k)
matrice
for (x in 1:k) {
if (sum(matrice[,x]) == 0){
matrice[round(runif(1,1,n)),x]=1
}
}
setwd("C:/Users/Bruno/Desktop/Uni-parallele/Parallel-Implementation-Systems-of-Boolean-linear-equations-using-XOR-operations/test")
n = 5;
k = 9;
theta = 0.1;
matrice = matrix(rbinom(n*k, 1, theta), nrow=3, ncol=k)
matrice
for (x in 1:k) {
if (sum(matrice[,x]) == 0){
matrice[round(runif(1,1,n)),x]=1
}
}
setwd("C:/Users/Bruno/Desktop/Uni-parallele/Parallel-Implementation-Systems-of-Boolean-linear-equations-using-XOR-operations/test")
n = 5;
k = 9;
theta = 0.1;
matrice = matrix(rbinom(n*k, 1, theta), nrow=n, ncol=k)
matrice
for (x in 1:k) {
if (sum(matrice[,x]) == 0){
matrice[round(runif(1,1,n)),x]=1
}
}
# Salva la matrice in un file di testo
write.table(matrice, file = "test2.txt", row.names = FALSE, col.names = FALSE, sep = " ")
setwd("C:/Users/Bruno/Desktop/Uni-parallele/Parallel-Implementation-Systems-of-Boolean-linear-equations-using-XOR-operations/test")
n = 5;
k = 9;
theta = 0.5;
matrice = matrix(rbinom(n*k, 1, theta), nrow=n, ncol=k)
matrice
for (x in 1:k) {
if (sum(matrice[,x]) == 0){
matrice[round(runif(1,1,n)),x]=1
}
}
# Salva la matrice in un file di testo
write.table(matrice, file = "test2.txt", row.names = FALSE, col.names = FALSE, sep = " ")
setwd("C:/Users/Bruno/Desktop/Uni-parallele/Parallel-Implementation-Systems-of-Boolean-linear-equations-using-XOR-operations/test")
n = 1e09;
k = 1e09;
theta = 0.5;
matrice = matrix(rbinom(n*k, 1, theta), nrow=n, ncol=k)
setwd("C:/Users/Bruno/Desktop/Uni-parallele/Parallel-Implementation-Systems-of-Boolean-linear-equations-using-XOR-operations/test")
n = 1e06;
k = 1e06;
theta = 0.5;
matrice = matrix(rbinom(n*k, 1, theta), nrow=n, ncol=k)
setwd("C:/Users/Bruno/Desktop/Uni-parallele/Parallel-Implementation-Systems-of-Boolean-linear-equations-using-XOR-operations/test")
n = 1e03;
k = 1e03;
theta = 0.5;
matrice = matrix(rbinom(n*k, 1, theta), nrow=n, ncol=k)
matrice
for (x in 1:k) {
if (sum(matrice[,x]) == 0){
matrice[round(runif(1,1,n)),x]=1
}
}
# Salva la matrice in un file di testo
write.table(matrice, file = "test4.txt", row.names = FALSE, col.names = FALSE, sep = " ")
setwd("C:/Users/Bruno/Desktop/Uni-parallele/Parallel-Implementation-Systems-of-Boolean-linear-equations-using-XOR-operations/test")
n = 1e02;
k = 1e02;
theta = 0.5;
matrice = matrix(rbinom(n*k, 1, theta), nrow=n, ncol=k)
matrice
for (x in 1:k) {
if (sum(matrice[,x]) == 0){
matrice[round(runif(1,1,n)),x]=1
}
}
# Salva la matrice in un file di testo
write.table(matrice, file = "test4.txt", row.names = FALSE, col.names = FALSE, sep = " ")
